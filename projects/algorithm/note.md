> https://algs4.cs.princeton.edu/home/

- 比较算法，编程模型
- 排序算法
- 搜索（二叉搜索树、红黑树、哈希表）
- 图（深度优先搜索、字串搜索、字典树、正则表达式、数据压缩）
- 系统编程、科学计算、商业应用、运筹学、不可解之间的连续、

# 1、基础

## 1.1 编程模型
> 标准输入输出、重定向、管道 <br>
> 二分查找 <br>

### 重定向与管道
重定向 <br>
1、`command < data.txt` data.txt -> 标准输入 -> command <br>
2、`command > data.txt` command -> 标准输出 -> data.txt <br>

管道 <br>
`command1 | command2` command1 -> 标准输出 -> 标准输入 -> command2 <br>

### 二分查找
```java
    public static int binarySearch(int[] a, int v) {
        int lo = 0;
        int hi = a.length - 1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            if (a[mid] == v) {
                return mid;
            } else if (a[mid] < v) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        return -1;
    }
```

#### 二分查找最左值（最右值）
```java
    private static int binarySearch(int[] a, int v, int lo, int hi, boolean left) {
        if (lo > hi) {
            return -1;
        }

        if (lo == hi) {
            if (a[lo] == v) {
                return lo;
            } else {
                return -1;
            }
        }

        // lo + 1 = hi时，mid=lo，会导致mid~hi没有减小
        int mid;
        if (left) {
          mid = lo + (hi - lo) / 2;
        } else {
          mid = lo + (hi - lo + 1) / 2;
        }
        
        if (a[mid] < v) {
            return binarySearch(a, v, mid + 1, hi, left);
        } else if (a[mid] > v) {
            return binarySearch(a, v, lo, mid - 1, left);
        } else {
            if (left) {
                return binarySearch(a, v, lo, mid, true);
            } else {
                return binarySearch(a, v, mid, hi, false);
            }
        }
    }
```

### 习题
#### 1.洗牌算法
> 这里是为洗牌牌组推荐的方案：<br>
> （i）获取一个密码学安全的伪随机数生成器 <br>
> （ii）为每张牌分配一个随机的 64bit 位的数字 <br>
> （iii）根据它们的数字对牌进行排序。


## 1.2 数据抽象
> java 数据相关 <br>


### 习题
#### 1.判断一个字符串 s 是另一个字符串 t 的循环旋转
`s.length() == t.length() && s.concat(s).indexOf(t) >=0`

## 1.3 栈和队列
> 数据类型：Bag Queue Stack <br>
> 可迭代集合 <br>

### Bag
`Bag` 包，不支持删除的集合

### Queue
`Queue` 队列

### Stack
`Stack` 栈

#### 算术表达式求值，Dijkstra's 2-stack algorithm
用于完全括号的算术表达式求值 <br>
1、将操作数推入操作数栈 <br>
2、将操作符推入操作符栈 <br>
3、忽略左括号 <br>
4、遇到右括号时，弹出一个操作符，弹出所需数量的操作数，并将该操作符应用于这些操作数的结果压入操作数栈 <br>

### 迭代
`Iterable` 

### 集合的实现
- 固定容量的数组
- 可调整大小的数组
- 链表

### 问题
#### 为何无法创建泛型数组
```java
public class ArrayStack<E> {
    private E[] es = new E[1]; // error 
}

```
java中的数组是协变的（covariant），但泛型不是 <br>
`String[]` 是 `Object[]` 的子类型，但 `Stack<String>` 不是 `Stack<Object>` 的子类型 <br>
为了解决这个问题，你需要执行一个未检查的转换 <br>
```java
public class ArrayStack<E> {
    private E[] es = (E[]) new Object[1];
}
```
创建并返回一个参数化类型的数组 **TODO 其他解决方案**
```java
import java.lang.reflect.Array;

public class GenericArrayFactory<E> {

    public E[] arrayOf(Class<E[]> clazz, int length) {
        return clazz.cast(Array.newInstance(clazz.getComponentType(), length));
    }

    public static void main(String[] args) {
        Integer[] intArray = new GenericArrayFactory<Integer>().arrayOf(Integer[].class, 42);
    }
}
```

## 1.4 算法分析

## 1.5 案例研究 并查集
> 连通分量 <br>
> Quick-find <br>
> Quick-union <br>
> Weighted quick-union <br>
> Weighted quick-union with path compression <br>

加权快速连接 **TODO 待实现** <br>
权=树的大小，即节点数量，将节点数量小的连接到节点数量大的 

带路径压缩的加权快速连接 **TODO 待实现** <br> 
find过程中将节点直接连接到根节点 

学习 TODO <br>
《Near-optimal fully-dynamic graph connectivity》

# 2、排序

## 2.1 基本排序
> 选择排序 <br>
> 插入排序 <br>
> 希尔排序 <br>

## 2.2 归并排序

## 2.3 快速排序

## 2.4 优先队列
> 堆

二叉堆：每个节点大于或等于该节点的两个子节点 <br>
以层序方式表示在数组中（不使用第一个元素）：位置`k`的父节点位于`k/2`，子节点位于`2k`和`2k+1` <br>
维护堆有序的方法：
```java
private void swim(int k) {
   while (k > 1 && less(k/2, k)) {
      exch(k, k/2);
      k = k/2;
   }
}

private void sink(int k) {
    while (2*k <= N) {
        int j = 2*k;
        if (j < N && less(j, j+1)) j++;
        if (!less(k, j)) break;
        exch(k, j);
        k = j;
    }
}
```
插入一个节点，将节点插入在数组末尾，然后上浮 <br>
移除最大的节点，将末尾节点换到第一个节点，然后第一个节点下沉

> 扩展 <br>
> 多路堆 <br>
> 可调整大小数组
> 索引优先队列：每个K关联一个整数索引

堆排序：构建一个堆，不断取出最值 <br>
或使用sink，swim方法直接在输入数组维护：从右往左构建（sink），有一个小子堆不断构建一个大子堆（堆序号从1开始，get，set时注意转换）

## 2.5 排序应用
> Java 的系统程序员选择使用快速排序（带三路划分）来实现原始类型方法，并使用归并排序来实现引用类型方法。这些选择的主要实际影响是在速度和内存使用（对于原始类型）之间进行权衡，以换取稳定性和保证性能（对于引用类型）。<br>
> 
> 排序算法解决其他问题：
> - 查找重复元素
> - Kendall tau distance
> - 优先队列，找出最大的M个值
> - 中位数和顺序统计
> 
> 应用
> - 商业计算（排序）
> - 信息搜索（二分查找）
> - 运筹学
> - 事件驱动模拟
> - 数值计算
> - 组合搜索
> - Prim算法和Dijkstra算法
> - 哈夫曼压缩
> - 字符串处理

# 3、搜索

## 3.1 符号表
> Key Value 映射 <br>
> 有序符号表 <br>
> 链表实现符号表 <br>
> 两数组+二分查找实现有序符号表 <br>


## 3.2 二叉搜索树

定义：二叉搜索树（BST）是一种二叉树，其中每个节点有一个键（以及一个相关联的值），并且满足这样的限制：任何节点的键都大于该节点左子树中所有节点的键，且小于该节点右子树中所有节点的键

## 3.3 平衡二叉搜索树
> 2-3搜索树 <br>
> 红黑树 <br>

2-3搜索树：
- 2节点包含一个键，两个链接，左链接指向较小键的2-3搜索树，右链接指向较大键的2-3搜索树
- 3节点包含两个键，三个链接，左链接指向较小键的2-3搜索树，中间链接指向介于节点中间键的2-3搜索树，右链接指向较大键的2-3搜索树

完全平衡的2-3搜索树：所有空链接到根节点的距离相同

2-3树插入操作：
- 向一个2节点插入：2节点转为3节点
- 向一个仅包含3节点的树插入：3节点临时转为4节点，4节点可以转为三个2节点
- 向一个父节点为2节点的3节点插入：3节点临时转为4节点，取中间键插入到父节点，父节点转为3节点
- 向一个父节点为3节点的3节点插入：3节点临时转为4节点，取中间键插入到父节点，父节点临时转为4节点，不断向上，直至达到一个2节点转为3节点结束，或根节点转为4节点，将根节点拆分为三个2节点

红黑树：2-3搜索树简单表示
- 左红黑树：3节点用单个向左倾斜的红色链接连接的两个节点、
  - 空链接认为是黑色
  - 忽略红色链接（将红色链接水平绘制），则所有空链接到根节点的距离相同
- 右红黑树：同理

红黑树插入操作（左红黑树为例）：红色链接的两个节点->3节点
- 向一个节点插入：插入的节点与该节点红色链接（若插入了右链接，则需要左旋）
- 向一个仅包含两个节点的树插入：根节点h，左节点x，h-x为红色
  - 若插入到h的右边，h-y为红色，h节点左右节点都为红色，需翻转颜色
  - 若插入到x的左边，x-y为红色，h的左边为红色，左边的左边也为红色，需右旋，再翻转颜色
  - 若插入到x的右边，x-y为红色，需左旋x，再右旋h，再翻转颜色
- 向一个父节点为黑色的节点的红节点插入：h-x，h为黑色，x为红色

红黑树插入，场景分析（插入一个新节点初始为红色） <br>
左旋h-x，x为红色，则h的子树，若x的子树到h的黑色距离相同，左旋后变为x-h，h为红色，其子树的黑色距离不变 <br>
右旋h-x-y，x、y为红色，若h、x、y的子树到h的黑色距离相同，右旋后，x左右节点为h和y，其子树的黑色距离不变，翻转颜色后子树黑色距离都+1，
但x变为红色，以x为根节点的子树与之前h为根节点的子树黑色距离相等，然后递归处理父节点 <br>
1、空树，插入一个节点，红色，根节点重置为黑色 <br>
2、一个节点，黑色，插入一个红色节点 <br>
3、插入的当前节点x是红色，父节点h是黑色
  - 当前节点无子节点：h-x-y，y是红色，需要旋转，h左右节点为x和y，翻转颜色

红黑树删除 TODO 
- 节点只有左孩子/右孩子：一定是黑-红，子孩子代替该节点并变黑
- 没有孩子
  - 红节点：直接删除
  - 黑节点
    - 兄弟是黑色
      - 兄弟至少有一个红孩子：变色+旋转
      - 兄弟孩子都是黑色：兄弟变红，双黑上移
    - 兄弟是红色：兄父变色，朝双黑旋转

## 3.4 哈希表

键是小整数，则键可作为数组索引，映射数据

哈希表主要操作
- 获取哈希值
  - 确定性
  - 计算高效
  - 均匀分布
- 解决哈希值冲突
  - 分离链接法
  - 开发寻址法，装载因子必须小于1

装载因子=键数量/表大小

## 3.5 搜索应用
> 稀疏向量和矩阵 TODO

# 4、图

## 4.1 无向图
术语：
- 自环：一条连接顶点自身的边
- 两条边平行：两边连接相同的顶点对
- 顶点的度：关联该顶点的边数
- 子图：一个图的边（及其关联的顶点）的子集
- 路径：由边连接的顶点序列，且没有重复的边
- 简单路径：没有重复顶点的路径
- 环：一条路径（至少一条边），其首位顶点相同
- 简单环：除首位顶点外，没有重复顶点的环
- 路径或环的长度：边的数量
- 两个顶点相连：存在一条包含他们的路径
- 图是连通的：每个顶点到其他顶点都存在一条路径
- 不连通的图：由一组连通分量组成，这些连通分量是极大的连通子图
- 无环图
- 树是无环连通图
- 森林是互不相交的树的集合
- 连通图的生成树：包含该图所有顶点且为单棵树的子图
- 二分图：顶点可以分成两集合，使得所有边都连接集合中一个顶点与另一个集合中的顶点

图表示：
- 邻接表
- 邻接矩阵

图操作：
- 深度优先搜索
- 广度优先搜索
- 连通分量

深度优先搜索应用：
- 环检测
- 二着色性
- 桥
- 二连通性
- 平面性

图应用：
- 符号图

# 5、字符串

# 6、上下文
